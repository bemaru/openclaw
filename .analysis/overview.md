# OpenClaw — Overview

## 프로젝트 철학

OpenClaw는 **"개인 소유의 AI 어시스턴트"** 라는 단일 비전으로 설계된 프로젝트다. 핵심 철학은 다음과 같다:

- **로컬 우선(Local-first)**: 클라우드 서비스에 데이터를 맡기지 않고, 자신의 하드웨어에서 실행
- **멀티채널 통합**: WhatsApp, Telegram, Discord, iMessage, Signal 등 사용자가 이미 쓰는 채널을 통해 상호작용
- **단일 사용자 모델**: 개인용 어시스턴트로 설계하여 멀티테넌시 복잡성 의도적 회피
- **투명성과 제어**: 설정/세션/스킬 모두 파일시스템 기반(`~/.openclaw/`)으로 사용자가 완전히 제어

CONTRIBUTING.md에서 드러나는 커뮤니티 가치:
- AI 생성 코드 환영 (투명성만 요구)
- 커뮤니티 중심의 스킬 개발 (ClawHub)
- 명확한 우선순위: **안정성 → UX → 성능**

## 해결하는 문제

개발자와 파워 유저가 직면하는 문제: "여러 메시징 앱에 흩어진 AI 채팅을 하나의 지능적 에이전트로 통합하고, 데이터를 직접 소유하고 싶다."

**기존 대안 대비 차별점:**

| 관점 | 기존 대안 (ChatGPT, Claude 앱 등) | OpenClaw |
|------|------|------|
| 데이터 소유 | 클라우드 서비스에 저장 | 자신의 기계에 저장 |
| 채널 | 전용 앱/웹만 사용 | 모든 메시징 앱 통합 |
| 에이전트 커스텀 | 제한적 | 완전한 설정 + 플러그인 |
| 라우팅 | 불가 | 채널/사용자/그룹별 에이전트 분기 |
| 확장성 | API만 제공 | Plugin SDK + Skills 생태계 |

## 기술 스택과 선택 이유

### 코어 런타임

| 기술 | 선택 이유 | 트레이드오프 |
|------|-----------|------------|
| **Node.js 22+ (ESM)** | 최신 모듈 시스템, 네이티브 fetch, 비동기 I/O | ESM 전환 비용, CJS 호환성 제한 |
| **TypeScript Strict** | 채널/provider 간 호환성을 컴파일 타임에 검증 | 초기 타이핑 비용, 런타임 오버헤드 없음 |
| **pi-mono Agent SDK** | Pi coding agent 내장, tool use/session/memory 지원 | SDK 의존성, 버전 결합도 |

### 메시징 채널 SDK

각 채널마다 **최적의 SDK를 개별 선택**하는 폴리글롯 전략:

```
Telegram  → grammY (Bot API, Runner/Throttler 내장)
WhatsApp  → Baileys (web 기반, QR 인증)
Slack     → @slack/bolt (Socket Mode)
Discord   → discord-api-types + express
Signal    → signal-utils
Line      → @line/bot-sdk
iMessage  → BlueBubbles 확장
```

**트레이드오프**: 표준화된 추상화 대신 각 채널의 네이티브 기능을 최대한 활용. 유지보수 비용은 높지만 채널별 최적 UX 제공.

### 개발 도구

| 도구 | 역할 | 선택 이유 |
|------|------|-----------|
| **oxfmt/oxlint** | 포맷팅/린팅 | Rust 기반 고속 처리 |
| **vitest** | 테스트 | ESM 네이티브 + 병렬 실행 |
| **tsdown/tsx** | 빌드/실행 | TypeScript 직실행, 빠른 빌드 |
| **pnpm workspace** | 패키지 관리 | 엄격한 의존성 격리, 디스크 효율 |

### 인프라 선택

| 구성요소 | 설계 | 이유 |
|----------|------|------|
| 설정 포맷 | JSON5 + Zod 검증 | 주석 허용 + 런타임 안전성 |
| 세션 저장 | JSONL (파일시스템) | 간단, 백업 용이, DB 불필요 |
| 통신 | WebSocket (Gateway) | 실시간 양방향, 모든 클라이언트 공유 |
| 네트워크 | Loopback 기본, Tailscale 옵션 | 보안 기본값 + VPN 확장 |

---

## 배울 점

1. **폴리글롯 채널 SDK 전략**: 표준화를 포기하고 각 채널별 최적 SDK를 선택함으로써 네이티브 기능 100% 활용. Channel Adapter 패턴으로 다양성을 관리
2. **"안정성 → UX → 성능" 우선순위 명문화**: 기여 가이드라인에 우선순위를 명시하여 설계 결정 시 일관된 기준 제공
3. **파일시스템 기반 상태 관리**: DB 없이 `~/.openclaw/` 디렉토리만으로 모든 상태를 관리하여 백업/이동/디버깅이 극도로 단순
4. **Doctor 명령 패턴**: `openclaw doctor --deep`으로 설정 검증, 채널 프로브, 모델 가용성 확인을 한 번에 수행

## 적용 아이디어

| OpenClaw 패턴 | EDR AI 적용 |
|---------------|-------------|
| Channel Adapter 패턴 | EDR 관리콘솔의 다양한 데이터 소스(로그, 이벤트, 알림)를 통합 수집할 때 소스별 Adapter 패턴 적용 |
| 계층적 바인딩 라우팅 | AI 기능별 요청을 사용자 역할/권한/컨텍스트에 따라 다른 LLM/프롬프트로 라우팅 |
| JSON5 + Zod 설정 검증 | AI 설정(모델, 프롬프트, 파라미터)을 스키마 기반으로 관리하여 런타임 안전성 확보 |
| Doctor 명령 | AI 기능 상태 진단 도구 — LLM 연결, API 키, 모델 가용성을 한 번에 점검 |
| 로컬 우선 세션 관리 | 보안 민감한 EDR 데이터의 AI 분석 세션을 로컬/온프레미스 우선으로 설계 |
